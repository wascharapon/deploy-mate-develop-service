// Creates action files for Go code
package main

import (
	"DeployMateDevelopService/internal/metadata"
	"errors"
	"flag"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"io"
	"os"
	"path/filepath"
	"strings"
	"text/template"

	"github.com/posener/goaction"
	"github.com/posener/goaction/actionutil"
	"github.com/posener/goaction/log"
	"github.com/posener/script"
	"gopkg.in/yaml.v2"
)

var (
	path     = flag.String("path", "./app/deploy_mate/main.go", "Path to main Go main package.")
	location = flag.String("location", "gke.cluster-rcf2", "Location ID")
	project  = flag.String("project", "toberich-staging", "Project ID")
	from     = flag.String("from", "admin-panel-fe", "from deploy")
	to       = flag.String("to", "admin-panel-fe-5678", "to deploy")
	image    = flag.String("image", "asia-southeast1-docker.pkg.dev/scamo-group/toberich-stag/admin-panel-fe@sha256:ce4b60aa2c823ebf1df92942fcde1d2e2aa98c99d7a369827264c5732e776426", "Image name")
)

const (
	action      = "action.yml"
	dockerfile  = "app/deploy_mate/Dockerfile" // เปลี่ยนตำแหน่ง Dockerfile
	autoComment = "#File generated by AgelCyber"
)

func main() {
	flag.Parse()

	// Load go code.
	fset := token.NewFileSet()
	pkgs, err := parser.ParseDir(fset, *path, nil, parser.ParseComments)
	if err != nil {
		log.Fatal(err)
	}

	// Get main package.
	var mainPkg *ast.Package
	for name, pkg := range pkgs {
		if name == "main" {
			mainPkg = pkg
			break
		}
	}
	if mainPkg == nil {
		log.Fatalf("No main package in path %q", *path)
	}

	// Parse Go code to Github actions metadata.
	m, err := metadata.New(mainPkg)
	if err != nil {
		var pe metadata.ErrParse
		if errors.As(err, &pe) {
			log.FatalFile(fset.Position(pe.Pos), err)
		}
		log.Fatal(err)
	}

	// Create action file.
	log.Printf("Writing %s\n", action)
	err = script.Writer("yml", func(w io.Writer) error {
		w.Write([]byte(autoComment))
		return yaml.NewEncoder(w).Encode(m)
	}).ToFile(action)
	if err != nil {
		log.Fatal(err)
	}

	// Create dockerfile
	log.Printf("Writing %s\n", dockerfile)
	dir, err := pathRelDir(*path)
	data := tmplData{
		Dir:   dir,
		Image: *image,
	}
	err = script.Writer("template", func(w io.Writer) error {
		w.Write([]byte(autoComment))
		return tmpl.Execute(w, data)
	}).ToFile(dockerfile)
	if err != nil {
		log.Fatal(err)
	}

	diff := gitDiff()

	if diff != "" {
		log.Printf("Applied changes:\n\n%s\n\n", diff)
	} else {
		log.Printf("No changes were made.")
	}

	if !goaction.CI {
		return
	}
}

func gitDiff() string {
	var diff strings.Builder
	for _, path := range []string{action, dockerfile} {
		// Add files to git, in case it does not exists
		d, err := actionutil.GitDiff(path)
		if err != nil {
			log.Fatal(err)
		}
		if d != "" {
			diff.WriteString(fmt.Sprintf("Path `%s`:\n\n", path))
			diff.WriteString(fmt.Sprintf("```diff\n%s\n```\n\n", d))
		}
	}
	return diff.String()
}

// Commit and push chnages to upstream branch.
func push() {
	err := actionutil.GitCommitPush(
		[]string{action, dockerfile},
		"Update action files")
	if err != nil {
		log.Fatal(err)
	}
}

// pathRelDir returns the containing directory of a given path in a relative form, relative to the
// working directory prefixed with "./"
func pathRelDir(path string) (string, error) {
	path, err := filepath.Abs(path)
	if err != nil {
		return "", err
	}

	wd, err := os.Getwd()
	if err != nil {
		return "", err
	}

	path, err = filepath.Rel(wd, path)
	if err != nil {
		return "", err
	}
	// If Rel returned ".", fix it to empty string which will eventually mutate to "./".
	if path == "." {
		path = ""
	}
	// Add a "./" prefix.
	if !strings.HasPrefix(path, "./") {
		path = "./" + path
	}
	return path, nil
}

type tmplData struct {
	Dir     string
	Image   string
	Install string
}

var tmpl = template.Must(template.New("dockerfile").Parse(`
FROM {{ .Image }}
RUN apk add git {{ .Install }}

COPY . /home/src
WORKDIR /home/src
RUN go build -o /bin/action {{ .Dir }}

ENTRYPOINT [ "/bin/action" ]
`))
